# -*- coding: utf-8 -*-
"""App Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G8yh7A9gP0kAbYIlEYKi7Bf5e0MMw0Et
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns
plt.style.use('seaborn')
sns.set(font_scale=1.8)

import plotly.offline as py
from plotly import tools
py.init_notebook_mode(connected=True)
import plotly.graph_objs as go
import missingno as msno
import random

from plotly import tools

# Supress unnecessary warnings so that presentation looks clean
import warnings
warnings.filterwarnings("ignore")

df_app='drive/MyDrive/Colab Notebooks/VIT PROJECTS/Recreated/AppleStore.csv'
df_app = pd.read_csv(df_app)

df_description='drive/MyDrive/Colab Notebooks/VIT PROJECTS/Recreated/appleStore_description.csv'
df_description = pd.read_csv(df_description)
df_description

df_app.isnull().sum()

"""- There aren't null data in the df_app."""

df_description.head()

df_description.isnull().sum()

"""- There aren't null data in the df_description.

## Merge datasets
"""

final_df = df_app
final_df

final_df['app_desc'] = df_description['app_desc']
final_df.columns

final_df['size_bytes_in_MB'] = final_df['size_bytes'] / (1024 * 1024.0)
final_df['size_bytes_in_MB']

final_df.head()

final_df.describe()

final_df.columns

final_df.dtypes

"""## adding new column for free or not"""

final_df['isPaid'] = final_df['price'].apply(lambda x: 1 if x > 0 else 0)

final_df['isPaid'].value_counts().plot.bar()
plt.xlabel('Is the Application Free?(Free = 0, Paid = 1)')
plt.ylabel('Count')
plt.title('Free vs Paid Applications')
plt.show()

final_df['isPaid'].value_counts()

print('There are {} Paid Apps in this dataset'.format(final_df['isPaid'].value_counts()[1]))
print('There are {} Free Apps in this dataset'.format(final_df['isPaid'].value_counts()[0]))

def configure_plotly_browser_state():
  import IPython
  display(IPython.core.display.HTML('''
        <script src="/static/components/requirejs/require.js"></script>
        <script>
          requirejs.config({
            paths: {
              base: '/static/base',
              plotly: 'https://cdn.plot.ly/plotly-latest.min.js?noext',
            },
          });
        </script>
        '''))

def enable_plotly_in_cell():
  import IPython
  from plotly.offline import init_notebook_mode
  display(IPython.core.display.HTML('''<script src="/static/components/requirejs/require.js"></script>'''))
  init_notebook_mode(connected=False)

"""## Countplot for each type of Prime_genre"""

def random_color_generator(number_of_colors):
    configure_plotly_browser_state()
    color = ["#"+''.join([random.choice('0123456789ABCDEF') for j in range(6)])
                 for i in range(number_of_colors)]
    return color 

cnt_srs = final_df['prime_genre'].value_counts()
text = ['{:.2f}%'.format(100 * (value / cnt_srs.sum())) for value in cnt_srs.values]

trace = go.Bar(
    x = cnt_srs.index,
    y = cnt_srs.values,
    text = text,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)
data = [trace]

layout = go.Layout(
    title = 'Prime genre',
    margin = dict(
        l = 100
    ),
    xaxis = dict(
        title = 'Genre'
    ),
    yaxis = dict(
        title = 'Count'
    ),
    width = 800,
    height = 500
)

fig = go.Figure(data=data, layout=layout)
enable_plotly_in_cell()
py.iplot(fig)

final_df_paid = final_df[final_df['isPaid'] == 1]
final_df_free = final_df[final_df['isPaid'] == 0]

cnt_srs1 = final_df_free['prime_genre'].value_counts()
text1 = ['{:.2f}%'.format(100 * (value / cnt_srs1.sum())) for value in cnt_srs1.values]

trace1 = go.Bar(
    x = cnt_srs1.index,
    y = cnt_srs1.values,
    text = text1,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)

cnt_srs2 = final_df_paid['prime_genre'].value_counts()
text2 = ['{:.2f}%'.format(100 * (value / cnt_srs2.sum())) for value in cnt_srs2.values]

trace2 = go.Bar(
    x = cnt_srs2.index,
    y = cnt_srs2.values,
    text = text2,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)

trace3 = go.Bar(
    x = cnt_srs1.index,
    y = cnt_srs1.values,
    text = text1,
    opacity = 0.7,
    name='Free'
)


trace4 = go.Bar(
    x = cnt_srs2.index,
    y = cnt_srs2.values,
    text = text2,
    opacity = 0.7,
    name='Not-Free'
)



fig = tools.make_subplots(rows=2, cols=2, specs = [[{}, {}], [{'colspan':2}, None]], 
                          subplot_titles=('(1) Countplot for Prime_genre of Free', '(2) Countplot for Prime_genre of Not-Free', 
                                          '(3) Grouped barplot containing Free(green) and Not-Free(red)'), print_grid=False)
fig.append_trace(trace1, 1, 1)
fig.append_trace(trace2, 1, 2)
fig.append_trace(trace3, 2, 1)
fig.append_trace(trace4, 2, 1)

fig['layout']['yaxis1'].update(title='Count')
fig['layout']['yaxis2'].update(title='Count')
fig['layout']['yaxis3'].update(title='Count')

fig['layout'].update(showlegend=False, width=800, height=800)
enable_plotly_in_cell()
py.iplot(fig)

"""### Figure 1
- For Free App, Top 3 is below.

(1) Games (2) Entertainments (3) Photo & Video
### Figure 2

- For Not-Free App, Top 3 is below

(1) Games (2) Education (3) Entertainments

## User rating depending on prime_genre
"""

cnt_srs = final_df[['prime_genre', 'user_rating']].groupby('prime_genre').mean()['user_rating'].sort_values(ascending=False)

trace = go.Bar(
    x = cnt_srs.index,
    y = cnt_srs.values,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)
data = [trace]

layout = go.Layout(
    title = 'User rating depending on Prime genre',
    margin = dict(
        l = 100
    ),
    xaxis = dict(
        title = 'Genre'
    ),
    yaxis = dict(
        title = 'Mean User Rating'
    ),
    width = 800,
    height = 500
)

fig = go.Figure(data=data, layout=layout)
enable_plotly_in_cell()
py.iplot(fig)

"""- With not considering 'isNotFree', The Apps for Productivity, Music and Photo & Video have higher mean user rating.
- The mean user rating of Book, Finance and Catalogs are less than 2.5.
"""

cnt_srs1 = final_df_free[['prime_genre', 'user_rating']].groupby('prime_genre').mean()['user_rating'].sort_values(ascending=False)
text1 = ['{:.2f}%'.format(100 * (value / cnt_srs1.sum())) for value in cnt_srs1.values]

trace1 = go.Bar(
    x = cnt_srs1.index,
    y = cnt_srs1.values,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)

cnt_srs2 = final_df_paid[['prime_genre', 'user_rating']].groupby('prime_genre').mean()['user_rating'].sort_values(ascending=False)
text2 = ['{:.2f}%'.format(100 * (value / cnt_srs2.sum())) for value in cnt_srs2.values]

trace2 = go.Bar(
    x = cnt_srs2.index,
    y = cnt_srs2.values,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)

trace3 = go.Bar(
    x = cnt_srs1.index,
    y = cnt_srs1.values,
    opacity = 0.7,
    name='Free'
)


trace4 = go.Bar(
    x = cnt_srs2.index,
    y = cnt_srs2.values,
    opacity = 0.7,
    name='Not-Free'
)



fig = tools.make_subplots(rows=2, cols=2, specs = [[{}, {}], [{'colspan':2}, None]], 
                          subplot_titles=('(1) Mean user rating of Free', '(2) Mean user rating of Not-Free', 
                                          '(3) Grouped barplot containing Free(green) and Not-Free(red)'), print_grid=False)
fig.append_trace(trace1, 1, 1)
fig.append_trace(trace2, 1, 2)
fig.append_trace(trace3, 2, 1)
fig.append_trace(trace4, 2, 1)

fig['layout']['yaxis1'].update(title='Mean User Rating')
fig['layout']['yaxis2'].update(title='Mean User Rating')
fig['layout']['yaxis3'].update(title='Mean User Rating')
fig['layout'].update(showlegend=False, width=800, height=800)
enable_plotly_in_cell()
py.iplot(fig)

"""### Figure 1
- For Free App, Top 3 is below.

(1) Productivity (2) Music (3) Photo & Video
### Figure 2

- For Not-Free App, Top 3 is below

(1) Catalogs (2) Shopping (3) Productivity
### Figure 3

- Book, Catalogs and Navigation Apps have much higher ratings when they are Not-free.

## App size based on prime_genre
"""

cnt_srs = final_df[['prime_genre', 'size_bytes_in_MB']].groupby('prime_genre').mean()['size_bytes_in_MB'].sort_values(ascending=False)
text = ['{:.2f}'.format(value) for value in cnt_srs.values]

trace = go.Bar(
    x = cnt_srs.index,
    y = cnt_srs.values,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)
data = [trace]

layout = go.Layout(
    title = 'Mean App size(MB) depending on Prime genre',
    margin = dict(
        l = 100
    ),
    xaxis = dict(
        title = 'Genre'
    ),
    yaxis = dict(
        title = 'Mean App size'
    ),
    width = 800,
    height = 500
)

fig = go.Figure(data=data, layout=layout)
enable_plotly_in_cell()
py.iplot(fig)

"""- With not considering 'isNotFree', Medical App has the largest size of ~400MB, followed by Games(~300MB)."""

cnt_srs1 = final_df_free[['prime_genre', 'size_bytes_in_MB']].groupby('prime_genre').mean()['size_bytes_in_MB'].sort_values(ascending=False)
text1 = ['{:.2f}%'.format(100 * (value / cnt_srs1.sum())) for value in cnt_srs1.values]

trace1 = go.Bar(
    x = cnt_srs1.index,
    y = cnt_srs1.values,
    text = text1,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)

cnt_srs2 = final_df_paid[['prime_genre', 'size_bytes_in_MB']].groupby('prime_genre').mean()['size_bytes_in_MB'].sort_values(ascending=False)
text2 = ['{:.2f}%'.format(100 * (value / cnt_srs2.sum())) for value in cnt_srs2.values]

trace2 = go.Bar(
    x = cnt_srs2.index,
    y = cnt_srs2.values,
    text = text2,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)

trace3 = go.Bar(
    x = cnt_srs1.index,
    y = cnt_srs1.values,
    text = text1,
    opacity = 0.7,
    name='Free'
)


trace4 = go.Bar(
    x = cnt_srs2.index,
    y = cnt_srs2.values,
    text = text2,
    opacity = 0.7,
    name='Not-Free'
)



fig = tools.make_subplots(rows=2, cols=2, specs = [[{}, {}], [{'colspan':2}, None]], subplot_titles=('Free', 'Not-Free', 'third'), print_grid=False)
fig = tools.make_subplots(rows=2, cols=2, specs = [[{}, {}], [{'colspan':2}, None]], 
                          subplot_titles=('(1) Mean App size(MB) of Free', '(2) Mean App size(MB) of Not-Free', 
                                          '(3) Grouped barplot containing Free(green) and Not-Free(red)'), print_grid=False)

fig.append_trace(trace1, 1, 1)
fig.append_trace(trace2, 1, 2)
fig.append_trace(trace3, 2, 1)
fig.append_trace(trace4, 2, 1)

fig['layout']['yaxis1'].update(title='Mean App size(MB)')
fig['layout']['yaxis2'].update(title='Mean App size(MB)')
fig['layout']['yaxis3'].update(title='Mean App size(MB)')
fig['layout'].update(showlegend=False, width=800, height=800)
enable_plotly_in_cell()
py.iplot(fig)

"""### Figure 1
- For Free App, Top 3 is below.

(1) Games (2) Medical (3) Education
### Figure 2

- For Not-Free App, Top 3 is below

(1) Medical (2) Games (3) Book
### Figure 3

- The bytesize of Not-Free Book, Catalogs and Medical Apps are more than 2 times than that of Free Book, Catalogs and Medical Apps.
- Because the service form of  those 3 Apps is information, the price for Apps have a relationship with the amount of information.
- For Games, I think the price is responsible for high quality graphic, good interface, etc.

## App price based on prime_genre

- The Apps (Business, Reference, Music, Productivity, Navigation, Education) have the mean price near to 5$.
"""

cnt_srs = final_df_paid[['prime_genre', 'price']].groupby('prime_genre').mean()['price'].sort_values(ascending=False)
text = ['{:.2f}%'.format(100 * (value / cnt_srs.sum())) for value in cnt_srs.values]

trace = go.Bar(
    x = cnt_srs.index,
    y = cnt_srs.values,
    text = text,
    marker = dict(
        color = random_color_generator(100),
        line = dict(color='rgb(8, 48, 107)',
                    width = 1.5)
    ),
    opacity = 0.7
)
data = [trace]

layout = go.Layout(
    title = 'Mean App price of Not-Free Apps',
    margin = dict(
        l = 100
    ),
    yaxis = dict(
        title = 'Mean App price'
    ),
    width = 800,
    height = 500
)

fig = go.Figure(data=data, layout=layout)
enable_plotly_in_cell()
py.iplot(fig)

"""- When considering only Not-Free apps, Medical App is the most expensive, near to 14$.

# Float columns
"""

df_temp = final_df.drop('id', axis=1)

data = [
    go.Heatmap(
        z = df_temp.corr().values,
        x = df_temp.corr().columns.values,
        y = df_temp.corr().columns.values,
        colorscale='YlGnBu',
        reversescale=False,
    )
]

layout = go.Layout(
    title='Pearson Correlation of float-type features',
    xaxis = dict(ticks=''),
    yaxis = dict(ticks='' ),
    width = 800, height = 800,
    margin = dict(
        l = 100
    )
)

fig = go.Figure(data=data, layout=layout)
enable_plotly_in_cell()
py.iplot(fig, filename='labelled-heatmap')

df_corr = final_df.drop('id', axis=1).corr()

"""## correlation between different attributes-"""

df_corr['user_rating'].sort_values(ascending=False)

df_corr['price'].sort_values(ascending=False)

"""# App Description"""

foo = final_df['app_desc'][0].split(' ')

import nltk
nltk.download("punkt")
nltk.download("stopwords")

import nltk
from nltk.corpus import stopwords

# Commented out IPython magic to ensure Python compatibility.
# %%time
# for i in range(final_df.shape[0]):
#     temp_desc = final_df['app_desc'][i]
#     temp_word_list = nltk.word_tokenize(temp_desc)
#     temp_word_list = [word.lower() for word in temp_word_list if word not in stopwords.words('english')]
#     for char in " {}()#&[]^`´-_·@|¿?¡!'+*\"?.!/;:<>’•“”–»%■,":
#         for ele in temp_word_list:
#             if char in ele:
#                 temp_word_list.remove(ele)
#     fdist = nltk.FreqDist(temp_word_list)
#     temp_srs = pd.Series(fdist).sort_values(ascending=False)
#     try:
#         final_df.loc[i, 'most_freq_word_1'] = temp_srs.index[0]
#         final_df.loc[i, 'most_freq_word_2'] = temp_srs.index[1]
#         final_df.loc[i, 'most_freq_word_3'] = temp_srs.index[2]
#     except:
#         final_df.loc[i, 'most_freq_word_1'] = temp_srs.index[0]

final_df.loc[df_app['user_rating'] > 4, 'most_freq_word_3'].value_counts().head(20).plot.bar()
plt.title("frequent words in app")
plt.show()

freq_total = nltk.FreqDist(final_df['most_freq_word_1'].tolist() + 
              final_df['most_freq_word_2'].tolist() +
             final_df['most_freq_word_3'].tolist())

freq_total = pd.Series(freq_total).sort_values(ascending=False)

freq_total.head(20).plot.bar()
plt.title("most frequent words")
plt.show()

"""# 4. Simple feature engineering and preparation"""

from sklearn.metrics import confusion_matrix
from sklearn.preprocessing import OneHotEncoder
from sklearn.model_selection import train_test_split
import xgboost as xgb

final_df['rating_count_before'] = final_df['rating_count_tot'] - final_df['rating_count_ver']

final_df.head()

df_train = final_df[['size_bytes_in_MB', 'isPaid', 'price', 'rating_count_before', 'sup_devices.num', 'ipadSc_urls.num', 'lang.num', 'vpp_lic', 'prime_genre']]
target = final_df['user_rating']

df_train = pd.get_dummies(df_train)

def categorize_rating(x):
    if x <= 4:
        return 0
    else:
        return 1

target = target.apply(categorize_rating)

target.astype(str).hist()
plt.title("")
plt.show()

X_train, X_test, y_train, y_test = train_test_split(df_train.values, target, test_size=0.2, random_state=1989, stratify=target)

print('X_train shape:', X_train.shape)
print('X_test shape:', X_test.shape)

"""# 5. Success prediction"""

from sklearn.metrics import accuracy_score
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score, cross_validate

from sklearn.ensemble import RandomForestClassifier
from lightgbm import LGBMClassifier
from xgboost import XGBClassifier

models = [RandomForestClassifier(), LGBMClassifier(), XGBClassifier()]

kfold = KFold(n_splits=5)#, random_state=1989)

clf_comparison = pd.DataFrame(columns=['Classfier_name', 'train_score', 'test_score'])

for i, model in enumerate(models):
    clf = model
    print(clf)
    cv_result = cross_validate(model, X_train, y_train, cv=kfold, scoring='accuracy')
    print(clf_comparison)
    print(cv_result)
    clf_comparison.loc[i,'Classfier_name'] = model.__class__.__name__
    #clf_comparison.loc[i,'train_score'] = cv_result['train_score'].mean()
    clf_comparison.loc[i,'test_score'] = cv_result['test_score'].mean()

clf_comparison

clf_comparison

cv_result

"""# 6. Success prediction with description variable"""

final_df.loc[:, 'isGame'] = final_df['app_desc'].apply(lambda x: 1 if 'game' in x.lower() else 0)

final_df.loc[:, 'descLen'] = final_df['app_desc'].apply(lambda x: len(x.lower()))

df_train = final_df[['size_bytes_in_MB', 'isPaid', 'price', 'rating_count_before', 'sup_devices.num', 'ipadSc_urls.num', 'lang.num', 'vpp_lic', 'prime_genre', 'isGame', 'descLen']]
target = final_df['user_rating']

df_train = pd.get_dummies(df_train)

def categorize_rating(x):
    if x <= 4:
        return 0
    else:
        return 1

target = target.apply(categorize_rating)

target.astype(str).hist()
plt.show()

X_train, X_test, y_train, y_test = train_test_split(df_train.values, target, test_size=0.2, random_state=1989, stratify=target)

print('X_train shape:', X_train.shape)
print('X_test shape:', X_test.shape)

models = [RandomForestClassifier(), LGBMClassifier(), XGBClassifier()]

kfold = KFold(n_splits=5)#, random_state=1989)

clf_comparison = pd.DataFrame(columns=['Classfier_name', 'train_score', 'test_score'])

for i, model in enumerate(models):
    clf = model
    cv_result = cross_validate(model, X_train, y_train, cv=kfold, scoring='accuracy')
    clf_comparison.loc[i, 'Classfier_name'] = model.__class__.__name__
    #clf_comparison.loc[i, 'train_score'] = cv_result['train_score'].mean()
    clf_comparison.loc[i, 'test_score'] = cv_result['test_score'].mean()

clf_comparison

"""# Conclusion
- At the beginning, I set a multi class classfication problem to predict user_rating using this dataset. I categorized user ratings into 5 groups, (1) 0-1 (2) 1-2 (3) 2-3 (4) 3-4 (5) 4~5.
- But, the output was bad.

- A binary classfication problem is used to predict success of apps, assuming that apps which have more than 4 user_rating is successful. 
- For this approach, the prediction accuracy is about 70%
"""